{"version":3,"file":"scripts.js","mappings":"AA6GA,MAAAA,UAAA,OAEAC,WAAA,GACA,IAAAC,cAAA,iBACAC,UAAA,aAGAC,aAAA,CACA,mBACA,kBACA,mBAEA,UACA,yBACA,WAIAC,KAAAC,iBAAA,mBAAAC,GACAC,QAAAC,IAAA,2BACAF,EAAAG,UACAC,OAAAC,KAAAT,WAAAU,KAAA,SAAAC,GACA,OAAAN,QAAAC,IAAA,qCACAK,EAAAC,OAAAX,aACA,GAEA,GAGAC,KAAAC,iBAAA,oBAAAC,GACA,OAAAC,QAAAC,IAAA,4BACAF,EAAAG,UACAC,OAAAK,OAAAH,KAAA,SAAAI,GACA,OAAAC,QAAAC,IAAAF,EAAAG,IAAA,SAAAC,GACA,GAAAA,IAAAlB,WAAAkB,IAAAnB,cACA,OAAAM,QAAAC,IAAA,qCAAAY,GACAV,OAAAW,OAAAD,EAEA,GACA,IAYAhB,KAAAkB,QAAAC,OACA,GAEAnB,KAAAC,iBAAA,iBAAAC,GACAC,QAAAC,IAAA,yBAAAF,EAAAkB,QAAAC,KACAnB,EAAAoB,YACAhB,OAAAiB,MAAArB,EAAAkB,SAAAZ,KAAA,SAAAgB,GACA,OAAAA,GAAAC,MAAAvB,EAAAkB,QACA,GAEA","names":["swVersion","hostPrefix","dataCacheName","cacheName","filesToCache","self","addEventListener","e","console","log","waitUntil","caches","open","then","cache","addAll","keys","keyList","Promise","all","map","key","delete","clients","claim","request","url","respondWith","match","response","fetch"],"sourceRoot":"webpack:///","sources":["apps/shell/src/ngsw-config.js"],"sourcesContent":["// const CACHE_NAME = 'v1';\n// const urlsToCache = [\n//   '/styles/main.css',\n//   '/script/main.js',\n//   '/images/logo.png',\n//   // Add URLs of font files and other assets you want to cache\n//   '/fonts/your-font-file.woff',\n//   '/assets/some-image.png'\n// ];\n\n// // The 'install' event is called when the service worker is first installed\n// // ... (the rest of the service worker code)\n\n// // The 'install' event is called when the service worker is first installed\n// self.addEventListener('install', function(event) {\n//   event.waitUntil(\n//     caches.open(CACHE_NAME)\n//       .then(function(cache) {\n//         console.log('Opened cache');\n//         // Add each URL to the cache one by one and log any that fail\n//         const cachePromises = urlsToCache.map(urlToCache => {\n//           return cache.add(urlToCache).catch(error => {\n//             console.error(`Caching failed for ${urlToCache}: ${error}`);\n//             return Promise.reject(error);\n//           });\n//         });\n//         return Promise.all(cachePromises);\n//       })\n//       .catch(error => {\n//         // If any of the cache additions fail, this will be logged here\n//         console.error(`Failed to install service worker: ${error}`);\n//       })\n//   );\n// });\n// // ... (the rest of the service worker code)\n\n// // The 'activate' event is called when the service worker starts\n// self.addEventListener('activate', function(event) {\n//   console.log('Service worker activating...');\n\n//   // Remove old caches that don't match the current version\n//   event.waitUntil(\n//     caches.keys().then(function(cacheNames) {\n//       return Promise.all(\n//         cacheNames.map(function(cacheName) {\n//           if (cacheName !== CACHE_NAME) {\n//             console.log('Deleting old cache:', cacheName);\n//             return caches.delete(cacheName);\n//           }\n//         })\n//       );\n//     })\n//   );\n// });\n\n// // The 'fetch' event is called when a network request is made\n// self.addEventListener('fetch', function(event) {\n//   event.respondWith(\n//     caches.match(event.request)\n//       .then(function(response) {\n//         // Cache hit - return the response from the cached version\n//         if (response) {\n//           return response;\n//         }\n\n//         // IMPORTANT: Clone the request. A request is a stream and can only be consumed once.\n//         // Since we are consuming this once by cache and once by the browser for fetch, we need to clone the response.\n//         var fetchRequest = event.request.clone();\n\n//         return fetch(fetchRequest).then(\n//           function(response) {\n//             // Check if we received a valid response\n//             if (!response || response.status !== 200 || response.type !== 'basic') {\n//               return response;\n//             }\n\n//             // IMPORTANT: Clone the response. A response is a stream and because we want the browser to consume the response\n//             // as well as the cache consuming the response, we need to clone it so we have two streams.\n//             var responseToCache = response.clone();\n\n//             caches.open(CACHE_NAME)\n//               .then(function(cache) {\n//                 cache.put(event.request, responseToCache);\n//               });\n\n//             return response;\n//           }\n//         );\n//       })\n//   );\n// });\n\n// Copyright 2016 Google Inc.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n//      http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n\n// Increase this version to deploy new code\nconst swVersion = '1.28';\n\nconst hostPrefix = '';\nvar dataCacheName = 'rock-pess-data';\nvar cacheName = 'rock-press';\n\n// Static resource to be cached.\nvar filesToCache = [\n   '/styles/main.css',\n  '/script/main.js',\n  '/images/logo.png',\n  // Add URLs of font files and other assets you want to cache\n  '/fonts/',\n  '/assets/some-image.png',\n  '/icons/'\n];\n\n// Service worker install hook.\nself.addEventListener('install', function(e) {\n  console.log('[ServiceWorker] Install');\n  e.waitUntil(\n    caches.open(cacheName).then(function(cache) {\n      console.log('[ServiceWorker] Caching app shell');\n      return cache.addAll(filesToCache);\n    })\n  );\n});\n\n// Service worker activation hook.\nself.addEventListener('activate', function(e) {\n  console.log('[ServiceWorker] Activate');\n  e.waitUntil(\n    caches.keys().then(function(keyList) {\n      return Promise.all(keyList.map(function(key) {\n        if (key !== cacheName && key !== dataCacheName) {\n          console.log('[ServiceWorker] Removing old cache', key);\n          return caches.delete(key);\n        }\n      }));\n    })\n  );\n  /*\n   * Fixes a corner case in which the app wasn't returning the latest data.\n   * You can reproduce the corner case by commenting out the line below and\n   * then doing the following steps: 1) load app for first time so that the\n   * initial New York City data is shown 2) press the refresh button on the\n   * app 3) go offline 4) reload the app. You expect to see the newer NYC\n   * data, but you actually see the initial data. This happens because the\n   * service worker is not yet activated. The code below essentially lets\n   * you activate the service worker faster.\n   */\n  return self.clients.claim();\n});\n\nself.addEventListener('fetch', function(e) {\n  console.log('[Service Worker] Fetch', e.request.url);\n  e.respondWith(\n    caches.match(e.request).then(function (response) {\n      return response || fetch(e.request);\n    })\n  );\n});"],"x_google_ignoreList":[]}